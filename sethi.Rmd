---
output:
  html_document: 
    keep_md: yes
    variant: markdown_github
---  

```{r}
library("sarsop")
library("dplyr")
library("parallel")
mc.cores = 8

log_dir = "compact-sethi-200"
dir.create(log_dir)
states <- seq(0, 2.5, len=200)
actions <- states  # Vector of actions: harvest
obs <- states

K = 0.9
discount = 0.95

## Usual assumption at the moment for reward fn
reward_fn <- function(x,h) pmin(x,h)

```



```{r}

## Ricker Models
vars <- expand.grid(r = 0.5, 
                    sigma_m = c(0.1, 0.4), 
                    sigma_g = 0.1, 
                    noise = c("lognormal"), 
                    model = c("ricker", "allen"))
fixed <- data.frame( K = K,
                     C = 0.2,
                     precision = 0.0000001,
                     timeout = 10000,
                     timeInterval = 2000,
                     max_state = max(states), 
                     max_obs = max(obs), 
                     max_action = max(actions), 
                     min_state = min(states), 
                     min_obs = min(obs), 
                     min_action = min(actions),
                     cost = "none", 
                     beta = 0) # Alternate reward fn if non-zero
pars <- data.frame(vars, fixed)
```

## Compute models for the above cases

```{r}
system.time(
models <- mclapply(1:dim(pars)[1], function(i){
  ## Select the model
  f <- switch(pars[i, "model"], 
              allen = sarsop:::allen(pars[i, "r"], pars[i, "K"], pars[i, "C"]),
              ricker = sarsop:::ricker(pars[i, "r"], pars[i, "K"]),
              bh = sarsop:::bh(pars[i, "r"], pars[i, "K"])
  )
  
  reward_fn <- switch(pars[i, "cost"],
      none = function(x,h) pmin(x,h),
      linear = function(x,h) pmin(x,h) - pars[i, "beta"] * h / min(x, 1e-12),
      quadratic = function(x,h) pmin(x,h) - pars[i, "beta"] * h ^ 2 / min(x, 1e-12))
  
  ## Compute matrices
  fisheries_matrices(states, actions, obs, 
                     reward_fn = reward_fn, 
                     f = f, 
                     sigma_g = pars[i, "sigma_g"], 
                     sigma_m  = pars[i, "sigma_m"],
                     noise = as.character(pars[i, "noise"]))
},
mc.cores = mc.cores)
)
```

## Compute alpha vectors

```{r}
system.time(
alphas <- mclapply(1:length(models), function(i){
         sarsop(models[[i]]$transition,
                models[[i]]$observation,
                models[[i]]$reward,
                discount = discount,
                precision = pars[i, "precision"],
                timeout = pars[i, "timeout"],
                timeInterval = pars[i, "timeInterval"],
                log_dir = log_dir,
                log_data = pars[i,])},
         mc.cores = mc.cores)
)
```
